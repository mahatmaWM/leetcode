<!-- TOC -->

- [递归](#%E9%80%92%E5%BD%92)
    - [解题步骤](#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4)
    - [解题模板](#%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF)
    - [算法分析](#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90)
- [回溯（Backtracking）](#%E5%9B%9E%E6%BA%AFbacktracking)
    - [解题步骤](#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4)
    - [代码模板](#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF)
- [深度优先搜索DFS](#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs)
    - [递归实现以及代码实现](#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
    - [非递归实现以及代码模板](#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF)
- [广度优先搜索BFS](#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs)
    - [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
    - [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
- [二分搜索（Binary Search）](#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2binary-search)
    - [递归解法代码模板](#%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF)
    - [非递归解法代码模板](#%E9%9D%9E%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF)
- [动态规划](#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

<!-- /TOC -->

# 递归

递归的基本性质就是函数调用，在处理问题的时候，递归往往是把一个大规模的问题不断地变小然后进行推导的过程。通俗来说，把要实现的递归函数看成是已经实现好的，直接利用解决一些子问题，然后需要考虑的就是如何根据子问题的解以及当前面对的情况得出答案。

## 解题步骤

    判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查（Sanity Check）。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。
    判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。

    将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个。
    利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。

## 解题模板

    function fn(n) {
        // 第一步：判断输入或者状态是否非法？
        if (input/state is invalid) {
            return;
        }

        // 第二步：判读递归是否应当结束?
        if (match condition) {
            return some value;
        }

        // 第三步：缩小问题规模
        result1 = fn(n1)
        result2 = fn(n2)
        ...

        // 第四步: 整合结果
        return combine(result1, result2)
    }

## 算法分析

分析非递归算法的时间复杂度非常直接，例如前一节课里分析过冒泡排序以及插入排序的时间复杂度，分析方法就是数有多少层循环，由于每层循环里面执行的操作都是对比和交换，时间复杂度是 O(1)，所以，最终的时间复杂度就是将每层循环的长度相乘。
分析递归算法推荐两种方法：**迭代法** 和 **公式法**

    公式法可以说是计算递归函数复杂度最方便的工具，当递归函数的时间执行函数满足如下的关系式时，我们可以利用公式法：T(n) = a×T(n/b) + f(n)。
    其中，f(n) 是每次递归完毕之后额外的计算执行时间。例如，在归并排序中，每次递归处理完两边的数组后，我们需要执行合并的操作，那么这个操作的执行时间就是 f(n)。

    当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(n^logba)。
    由于时间复杂度求的是上界（upper bound)，通过对比递归部分的时间复杂度和 f(n) 的大小关系，得出最后的整体时间复杂度。牢记以下三种情况和相应公式：
    当递归部分的执行时间 nlog(b)a 大于 f(n) 的时候，最终的时间复杂度就是 O(n^logba)。
    当递归部分的执行时间 nlog(b)a 小于 f(n) 的时候，最终的时间复杂度就是 f(n)。
    当递归部分的执行时间 nlog(b)a 等于 f(n) 的时候，最终的时间复杂度就是 O(n^logba)logn。

# 回溯（Backtracking）

回溯则是利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点的过程。
回溯实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地小心翼翼地进行向前试探，会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去，也就是说，它可以帮助我们避免走很多的弯路。
回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。

## 解题步骤

    判断当前情况是否非法，如果非法就立即返回；
    当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回；
    当前情况下，遍历所有可能出现的情况并进行下一步的尝试；
    递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试。

## 代码模板

    function fn(n) {

        // 第一步：判断输入或者状态是否非法？
        if (input/state is invalid) {
            return;
      }

        // 第二步：判读递归是否应当结束?
        if (match condition) {
            return some value;
      }

        // 遍历所有可能出现的情况
        for (all possible cases) {
      
            // 第三步: 尝试下一步的可能性
            solution.push(case)
            // 递归
            result = fn(m)

            // 第四步：回溯到上一步
            solution.pop(case)
        } 
    }

# 深度优先搜索DFS

DFS解决的是连通性的问题，即给定两个点，一个是起始点，一个是终点，判断是不是有一条路径能从起点连接到终点。必须依赖栈（Stack），特点是后进先出（LIFO）。

例题分析一
给定一个二维矩阵代表一个迷宫，迷宫里面有通道，也有墙壁，通道由数字 0 表示，而墙壁由 -1 表示，有墙壁的地方不能通过，那么，能不能从 A 点走到 B 点。

## 递归实现以及代码实现

代码看上去很简洁；实际应用中，递归需要压入和弹出栈，栈深的时候会造成运行效率低下。

    boolean dfs(int maze[][], int x, int y) {
        // 第一步：判断是否找到了B
        if (x == B[0] && y == B[1]) {
            return true;
        } 

        // 第二步：标记当前的点已经被访问过
        maze[x][y] = -1;

        // 第三步：在四个方向上尝试
        for (int d = 0; d < 4; d++) {
            int i = x + dx[d], j = y + dy[d];

            // 第四步：如果有一条路径被找到了，返回true
            if (isSafe(maze, i, j) && dfs(maze, i, j)) {
                return true;
            }
        }
        // 付出了所有的努力还是没能找到B，返回false
        return false;
    }

## 非递归实现以及代码模板

栈支持压入和弹出；栈能提高效率。

    boolean dfs(int maze[][], int x, int y) {
        // 创建一个Stack
        Stack<Integer[]> stack = new Stack<>();

        // 将起始点压入栈，标记它访问过
        stack.push(new Integer[] {x, y});
        maze[x][y] = -1;
        
        while (!stack.isEmpty()) {
            // 取出当前点
            Integer[] pos = stack.pop();
            x = pos[0]; y = pos[1];
          
            // 判断是否找到了目的地
            if (x == B[0] && y == B[1]) {
              return true;
            }
        
            // 在四个方向上尝试  
            for (int d = 0; d < 4; d++) {
                int i = x + dx[d], j = y + dy[d];
                
            if (isSafe(maze, i, j)) {
                stack.push(new Integer[] {i, j});
                maze[i][j] = -1;
                }
            }
        }
        return false;
    }

# 广度优先搜索BFS

广度优先搜索，一般用来解决最短路径的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束。
广度优先的搜索可以同时从起始点和终点开始进行，称之为双端 BFS。这种算法往往可以大大地提高搜索的效率。

## 解题思路

依赖队列（Queue），先进先出（FIFO）。一层一层地把与某个点相连的点放入队列中，处理节点的时候正好按照它们进入队列的顺序进行。

## 代码实现

    void bfs(int[][] maze, int x, int y) {
        // 创建一个队列queue，将起始点A加入队列中
        Queue<Integer[]> queue = new LinkedList<>();
        queue.add(new Integer[] {x, y});
      
        // 只要队列不为空就一直循环下去  
        while (!queue.isEmpty()) {
            // 从队列的头取出当前点
            Integer[] pos = queue.poll();
            x = pos[0]; y = pos[1];
          
            // 从四个方向进行BFS
            for (int d = 0; d < 4; d++) {
                int i = x + dx[d], j = y + dy[d];
            
                if (isSafe(maze, i, j)) {
                    // 记录步数（标记访问过）
                    maze[i][j] = maze[x][y] + 1;
                    // 然后添加到队列中  
                    queue.add(new Integer[] {i, j});
                    // 如果发现了目的地就返回  
                    if (i == B[0] && j == B[1]) return;
                }
            }
        }
    }

# 二分搜索（Binary Search）

二分搜索是一种在有序数组中查找某一特定元素的搜索算法。从定义可知，运用二分搜索的前提是数组必须是排好序的。另外输入并不一定是数组，也有可能是给定一个区间的起始和终止的位置。

优点：时间复杂度是 O(logN)，因此也称为对数搜索。
缺点：要求待查找的数组或者区间是排好序的。对数组进行动态的删除和插入操作并完成查找，平均复杂度会变为 O(n)。此时应当考虑采取自平衡的二叉查找树：
在O(NlogN)的时间内用给定的数据构建出一棵二叉查找树；
在O(logN)的时间里对目标数据进行搜索；
在O(logN)的时间里完成删除和插入的操作。

当输入的数组或者区间是排好序的，同时又不会经常变动，而要求从里面找出一个满足条件的元素的时候，二分搜索就是最好的选择。

## 递归解法代码模板

优点：简洁；缺点：执行消耗大
例题：假设我们要从一个排好序的数组里 {1, 3, 4, 6, 7, 8, 10, 13, 14} 查看一下数字 7 是否在里面，如果在，返回它的下标，否则返回 -1。
代码实现，递归写法的代码模板如下，[low, high]两边闭的写法。

    // 二分搜索函数的定义里，除了要指定数组 nums 和目标查找数 target 之外，还要指定查找区间的起点和终点位置，分别用 low 和 high 去表示。
    int binarySearch(int[] nums, int target, int low, int high) {
        // 为了避免无限循环，先判断，如果起点位置大于终点位置，表明这是一个非法的区间，已经尝试了所有的搜索区间还是没能找到结果，返回 -1。
        if (low > high) {return -1;}       
        // 取正中间那个数的下标 middle。
        int middle = low + (high - low) / 2;
        // 判断一下正中间的那个数是不是要找的目标数 target，是，就返回下标 middle。    
        if (nums[middle] == target) {return middle;}
        // 如果发现目标数在左边，就递归地从左半边进行二分搜索，否则从右半边递归地进行二分搜索。
        if (target < nums[middle]) {
            return binarySearch(nums, target, low, middle - 1);
           } else {
            return binarySearch(nums, target, middle + 1, high);
        }
    }

## 非递归解法代码模板

采用[l, r)前闭后开的写法，这会影响l，r指针移动的方式
```python
def searchInsert(l,r):
    while l < r:
        mid = l + (r - l) // 2
        if f(mid): return mid #optional
        if g(mid):  # 特别注意，这里用>=判断，则最后返回的l是，使这里成立的最小的值l
            r = mid  #new range[l, m)
        elif l(mid):
            l = mid + 1 #new range[m+1,r)
    return l  #or not found
```

[low right]闭区间的写法

    int binarySearch(int[] nums, int target, int low, int high) {
       // 在 while 循环里，判断搜索的区间范围是否有效
       while (low <= high) {
            // 计算正中间的数的下标
            int middle = low + (high - low) / 2;
            // 判断正中间的那个数是不是要找的目标数 target。如果是，就返回下标 middle
            if (nums[middle] == target) {return middle;}
            // 如果发现目标数在左边，调整搜索区间的终点为 middle - 1
            // 否则，调整搜索区间的起点为 middle + 1
            if (target < nums[middle]) {
                high = middle - 1;
            } else {
                low = middle + 1;
            }
       }
       // 如果超出了搜索区间，表明无法找到目标数，返回 -1  
       return -1;
    }

# 动态规划

1、最优子结构（Optimal Substructure)，一般由最优子结构，推导出一个状态转移方程 f(n)，就能很快写出问题的递归实现方法。

2、重叠子问题，动态规划是编程的方法指，可以借助编程的技巧去保证每个重叠的子问题只会被求解一次。引出了动态规划的第二个重要的属性：重叠子问题（Overlapping Sub-problems）。（自顶向下+记忆化 或者 自底向上+dp数组）

运用动态规划去解决问题，最难的地方有两个：
1、应当采用什么样的数据结构来保存什么样的计算结果
2、如何利用保存下来的计算结果推导出状态转移方程
第一个难点，不仅是为了避免重复的计算，也是推导状态转移方程的关键。这一难点往往是在把问题规模缩小的过程中进行的。
解决技巧：假设已经把所有子问题的最佳结果都计算出来了，那么只需要考虑，如何根据这些子问题的结果来得出最终的答案。

根据动态规划问题的难易程度，把常见的动态规划面试题分成如下三大类。
1、线性规划，面试题中最常见也是最简单的一种。
线性，就是说各个子问题的规模以线性的方式分布，并且子问题的最佳状态或结果可以存储在一维线性的数据结构里，例如一维数组，哈希表等。
2、区间规划
区间规划，就是说各个子问题的规模由不同的区间来定义，一般子问题的最佳状态或结果存储在二维数组里。一般用 dp[i][j] 代表从第 i 个位置到第 j 个位置之间的最佳状态或结果。解这类问题的时间复杂度一般为多项式时间，对于一个大小为 n 的问题，时间复杂度不会超过 n 的多项式倍数。例如，O(n)=n^k，k 是一个常数，根据题目的不同而定。
3、约束规划
在普通的线性规划和区间规划里，一般题目有两种需求：统计和最优解。
这些题目不会对输出结果中的元素有什么限制，只要满足最终的一个条件就好了。但是在很多情况下，题目会对输出结果的元素添加一定的限制或约束条件，增加了解题的难度。